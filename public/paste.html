<!DOCTYPE html>
<html>
<head>
<style>
  .my-child {
    height: 128px;
    width: 128px;
    border: 1px solid orange;
    display: inline-block;
    position: relative;
  }
  .my-child canvas {
    height: 128px;
    width: 128px;
    position: absolute;
    top: 0;
    left: 0;
    border: 3px solid green;
  }
  .canvas-area canvas {
    height: 64px;
    width: 64px;
    /* position: absolute;
    top: 0;
    left: 0; */
    border: 3px solid green;
  }
  .canvas-area img {
    height: 64px;
    width: 64px;
    /* position: absolute;
    top: 0;
    left: 0; */
    border: 3px solid green;
  }
</style>
</head>
<body>
  <h1>Paste</h1>
  <div id="cosmic-area"></div>

  <div class="canvas-area">
    Canvas: <canvas id="canv" width="64" height="64"></canvas>
    <img />
  </div>

<script>
(function() {
  
  let unicornConfigs = [];

  let selectedIndex = 0;

  let pixelWidth = 64;

  const sendPixelsToUnicorn = (index, payload) => {
    const config = unicornConfigs[index];
		if (!config) {
			console.log('Cant find config', unicornConfigs, index);
			return;
		}
		const ip = config.ip;
		// setFetchState(curr => {
		// 	return {
		// 		...curr,
		// 		[ip]: {
		// 			...curr[ip],
		// 			isSaving: true,
		// 		}
		// 	};
		// });

		const url = `http://${ip}/set_pixels`;

		const requestOptions = {
			method: 'POST',
			body: payload
		};
		fetch(url, requestOptions)
			.then(response => response.text())
			.then(data => {
				if (data === 'success') {
					// dataUrl is used for showing the preview
					//unicornConfigs[selectedIndex].dataUrl = dataUrl;
					unicornConfigs[selectedIndex].dataRgbaArray = payload;
				}
			}).finally(() => {
				// setFetchState(curr => {
				// 	return {
				// 		...curr,
				// 		[ip]: {
				// 			...curr[ip],
				// 			isSaving: false,
				// 		}
				// 	};
				// });
			});
  };

  const getImageDataFromEmojiWithCanvas = () => {
		const img = document.querySelector('.canvas-area img');
		//console.log('img', img);
		if (img) {
			img.setAttribute('crossOrigin', 'Anonymous');
			const c = document.querySelector('#canv');
			//const ctx = c.getContext('2d', { willReadFrequently: true });
			const ctx = c.getContext('2d');
			if (ctx) {
				ctx.clearRect(0, 0, pixelWidth, pixelWidth);
				console.log('Writing img to canvas...');
				ctx.drawImage(img, 0, 0, pixelWidth, pixelWidth);
				var d = ctx.getImageData(0, 0, pixelWidth, pixelWidth);
				console.log('Canvas getImageData() result:', d);
				return d;
			}
		} else {
			return null;
		}
	};

  const onPaste = (event) => {
    const items = event.clipboardData?.items;
    if (!items) { return; }
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
  
      if (item.type.indexOf("image") !== -1) {
        const blob = item.getAsFile();
        const reader = new FileReader();
  
        reader.addEventListener("load", function() {
          console.log('reader.result is', reader.result);
          //imagePreview.src = reader.result;
          const img = document.querySelector('.canvas-area img');
          img.src = reader.result;
          setTimeout(() => {
            const z = getImageDataFromEmojiWithCanvas();
            if (z) {
              console.log('got imagedata from canvas', z.data);
              // for(let i=0;i<d.data.length;i=i+4) {
              // }
              let a = [];
              let b = [];
              let c = [];
              let d = [];
              for(let j=0;j<64;j++) {
                for(let i=0;i<64;i++) {
                  const index = (j * 64 + i) * 4;
                  if (i < 32 && j < 32) {
                    a.push(z.data[index]);
                    a.push(z.data[index+1]);
                    a.push(z.data[index+2]);
                    a.push(z.data[index+3]);
                  }
                  if (i >= 32 && j < 32) {
                    b.push(z.data[index]);
                    b.push(z.data[index+1]);
                    b.push(z.data[index+2]);
                    b.push(z.data[index+3]);
                  }
                  if (i < 32 && j >= 32) {
                    c.push(z.data[index]);
                    c.push(z.data[index+1]);
                    c.push(z.data[index+2]);
                    c.push(z.data[index+3]);
                  }
                  if (i >= 32 && j >= 32) {
                    d.push(z.data[index]);
                    d.push(z.data[index+1]);
                    d.push(z.data[index+2]);
                    d.push(z.data[index+3]);
                  }
                }
              }
              console.log('data to send to unicorns', a, b, c, d);

              //sendPixelsToUnicorn(0, a);
              //sendPixelsToUnicorn(1, b);
              //sendPixelsToUnicorn(2, c);
              //sendPixelsToUnicorn(3, d);
              sendPixelsToUnicorn(0, new Uint8Array(a));
              sendPixelsToUnicorn(1, new Uint8Array(b));
              sendPixelsToUnicorn(2, new Uint8Array(c));
              sendPixelsToUnicorn(3, new Uint8Array(d));
              //sendPixelsToUnicorn(d.data);
            }
          }, 0);
        });
        console.log('blob', blob);
        if (blob) {
          const slicedBlob = blob.slice(0, blob.size, blob.type);
          console.log('slicedBlob', slicedBlob);
          reader.readAsDataURL(slicedBlob);
        }
        //reader.readAsDataURL(blob);
      }
    }
  };

	document.addEventListener("paste", onPaste);



  const writePixelsToCanvas = (index, dataRgbaArray) => {
    var c = document.getElementById(`canvas-${index}`);
		var ctx = c?.getContext("2d");
		if (ctx) {
      console.log('writePixelsToCanvas', index, dataRgbaArray);
      //ctx.scale(2, 2);
			if (dataRgbaArray) {
				for (var y = 0; y < 32; y++) {
					for (var x = 0; x < 32; x++) {
						const index = (y * 32 + x) * 4;
						// get rgba data
						const r = dataRgbaArray[index];
						const g = dataRgbaArray[index + 1];
						const b = dataRgbaArray[index + 2];
						const a = dataRgbaArray[index + 3];

						// convert rgba to rgb
						const aa = a / 255;
						const rr = Math.round(r * aa);
						const gg = Math.round(g * aa);
						const bb = Math.round(b * aa);

						// Draw rgba to canvas (does not work)
						//ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;

						// Draw rgb to canvas
						ctx.fillStyle = `rgb(${rr}, ${gg}, ${bb})`;
						ctx.fillRect(x, y, 1, 1);
					}
				}
        //ctx.scale(2, 2);
			} else {
				// no data, draw black
				ctx.fillStyle = `rgb(0, 0, 0)`;
				ctx.fillRect(0, 0, 32, 32);
			}
      
		}
  };

  

  const readPixelsFromCosmic = (index) => {
    const ip = unicornConfigs[index].ip;
    const url = `http://${ip}/get_pixels`;
		const requestOptions = {
			method: 'GET',
		};
    console.log(`readPixelsFromCosmic(${index})`, url);
		fetch(url, requestOptions)
			.then(response => {
				//console.log('got response', response.body.length);
				//return response.blob();
				return response.arrayBuffer();
			})
			.then(data => {
				const arrayFromBuffer = new Uint8Array(data);
				// Convert Uint8Array into number[]
				const numberArray = [];
				for (var i = 0; i < arrayFromBuffer.length - 1; i++) {
					numberArray.push(arrayFromBuffer[i]);
				}

				unicornConfigs[index].dataRgbaArray = numberArray;

        writePixelsToCanvas(index, numberArray);

				// setFetchState(curr => {
				// 	return {
				// 		...curr,
				// 		[ip]: {
				// 			...curr[ip],
				// 			isLoading: false,
				// 			isError: false,
				// 			errorMessage: '',
				// 			errorCount: 0,
				// 		}
				// 	};
				// });

			}).catch((err) => {
				console.log('ERROR: get_pixels catch');
				unicornConfigs[index].dataRgbaArray = undefined;

				// setFetchState(curr => {
				// 	return {
				// 		...curr,
				// 		[ip]: {
				// 			...curr[ip],
				// 			isLoading: false,
				// 			isError: true,
				// 			errorMessage: `Error loading ${url}`,
				// 			errorCount: curr[url] ? curr[url].errorCount + 1 : 1,
				// 		}
				// 	};
				// });
			});
  };

  

  const drawCosmicHTML = () => {
    const config = unicornConfigs;
    console.log('will draw ' + config.length);
    const ca = document.querySelector('#cosmic-area');
    ca.innerHTML = '';
    for(let i=0;i<config.length;i++) {

      if (i == 2) {
        ca.append(document.createElement('br'));
      }

      let d = document.createElement('div');
      d.id = `cosmic-${i}`;
      d.className = 'my-child';
      d.innerHTML = `
      <canvas
        id="canvas-${i}"
        height="64"
        width="64"
      ></canvas>
      <div>
        ${i} ${config[i].name} ${config[i].ip}
      </div>
      `;
      ca.append(d);
    }
  };

  const fetchConfig = () => {

    const data = new Promise((resolve, reject) => {
      fetch('./config-unicorns.json')
        .then(respond => {
          resolve(respond.json());
        }).catch(err => {
          reject(err);
        });
    });
  
    data.then(json => {
      console.log(json);
      unicornConfigs = json;

      drawCosmicHTML();

      readPixelsFromCosmic(0);
      readPixelsFromCosmic(1);
      readPixelsFromCosmic(2);
      readPixelsFromCosmic(3);

    }).catch(err => {
      console.log('err', err);
    });
  };

  const scaleUp = (index) => {
    var c = document.getElementById(`canvas-${index}`);
		var ctx = c?.getContext("2d");
		if (ctx) {
      ctx.scale(2, 2);
    }
  };

  setInterval(() => {
    readPixelsFromCosmic(0);
    readPixelsFromCosmic(1);
    readPixelsFromCosmic(2);
    readPixelsFromCosmic(3);
  }, 15 * 1000);

  setTimeout(() => {
    scaleUp(0);
    scaleUp(1);
    scaleUp(2);
    scaleUp(3);
  }, 100);

  fetchConfig();

})();
</script>
</body>
</html>